-*
Compute the parameterization of a network under thea given model
Input: 
N	  -- a network of Network type
M	  -- a modle M of Model type
Optional Input:
includeQs -- a Boolean variable which specifies whether or not to include the Fourier coordinates in the output
Output: 
polynomials representing the parameterization.

If includeQs is true, then the polynomials are in the ring with variables a, b, and q's.
If includeQs is false, then the polynomials are in the ring only with variables a and b's.
(Created by mh, modified by rh on 2024-11-04)
*-
computeParameterization = method(Options => {includeQs => true}) 
computeParameterization (Network, Model) := o-> (N,M) -> (
    a := local a;
    b := local b;
    e := local e;
    i := local i;
    q := local q;
    nLeaves := #(getLeaves N);
    y := getTransformTable M;
    L := getNucleotideSequence M; -- the equivance classes
    reticulations := getReticulationEdges N; edges := getEdges N;
    
    -- Constructing the boolean (quotation) ring R = QQ[e_,a_,b_,i_]/(e_^2, a_^2, b_^2, i_^2)
    varList := flatten(apply(#edges, j -> {e_(edges#j), a_(edges#j), b_(edges#j)})) | toList(i_1..i_nLeaves);
    S := QQ[varList]; -- this ring contains variables e, a, and b, each indexed by the edges
    varSqList := apply((gens S)_{0..3*(#edges)-1}, j -> j^2);
    R := S/(ideal varSqList);
    sigma := generateSigma(N,R); -- sigma is the state vector for each edge before deleting edges and evaluate
    
    -- List out the fourier coordinates (the q-variables)
    fourierCoordinates := toList apply(L,j-> q_(toSequence apply(#j, k -> y#(j#k)))); 
    ABQ := QQ[fourierCoordinates,flatten(apply(#edges, j -> {a_(edges#j),b_(edges#j)}))];
    out := apply(#L, j -> findVariable(flatten entries vars ABQ, toString fourierCoordinates#j) - sub(generateQ(sigma,N,L#j,R),ABQ));   
    if not o#includeQs then (
	parameterization := apply(L,j -> generateQ(sigma,N,j,R));
	AB := QQ[flatten(apply(#edges, j -> {a_(edges#j),b_(edges#j)}))];
	out = apply(parameterization, f -> sub(f,AB));
	);
    out
    )

-*
This function generates the state matrix for a given network N in the ring R. This is a subroutine for computeParameterization.
Input:
N -- a network of Network type
R -- the ring in which the parameterization is computed
Output:
a state matrix sigma in R representing the states at each node of the network N
*-
generateSigma = method()
generateSigma (Network,Ring) := (N,R) -> (
    Rvars := flatten entries vars R;
    EPListSorted := getEdges N;
    nLeaves := #(getLeaves N);
    numV := #(unique flatten  EPListSorted);
    leafEdgeList := EPListSorted_{0..nLeaves-1};
    edgeList := EPListSorted_{nLeaves..#EPListSorted - 1};
    matA := mutableIdentity(R,numV);
    for i from 0 to numV-1 do matA_(i,i) = 0; -- initiate a mutable matrix A with all entries 0
    -*
    The following two lines of code construct an adjacent matrix A with e_ij on the leaf 
    positions (A_ij) and e_kl on the internal edges positions (both A_kl and A_lk)
    *-
    scan(#leafEdgeList,j -> (
	    pair := leafEdgeList_j;
	    matA_(pair_1-1,pair_0-1)=Rvars_(1+j*3);)
	);
    scan(#edgeList,k -> (
	    pair := edgeList_k;
	    x := pair_0-1;
	    y := pair_1-1;
	    matA_(y,x) = Rvars_(#leafEdgeList+1+k*3);
	    matA_(x,y) = Rvars_(#leafEdgeList+1+k*3);
	    ));
    -- v is the initial state with first nleaves entries (i_leafIndex) and 0 otherwise 
    v := transpose matrix{Rvars_{-nLeaves..-1}|apply(numV-nLeaves,j -> 0)};
    -- Find sigma
    sigma := mutableMatrix sub(v,R);
    for j from 1 to #EPListSorted do sigma = sigma + (matA^j)*(mutableMatrix v);
    transpose matrix{apply(numRows sigma, j -> sum flatten entries (coefficients sigma_(j,0))_0)}
    )

-*
Given an equivalnce class i (e.g. AAAA or ACGT), generate the polynomial formula for q_i under network N
Input:
sigma		   -- the state matrix generated by generateSigma
N		   -- a network of Network type
nucleotideSequence -- a sequence of nucleotides (ACGT) represented as a list of representatives from the model M
R		   -- the ring in which the parameterization is computed
Output:
a polynomial in R representing the parameterization of the model for the given sequence under the network N
*-
generateQ = method()
generateQ (Matrix,Network,Sequence,Ring) := (sigma,N,nucleotideSequence,R) -> (
    Rvars := flatten entries vars R;
    W := ZZ/2;
    reticulationPairList := getReticulationEdges N; EPListSorted := getEdges N;
    reticulationPairs := apply(reticulationPairList,j->apply(j,l->findVariable(Rvars,concatenate("e_",toString l))));
    (F1,F2) := iMap(nucleotideSequence,#EPListSorted,R);
    -- Enumerate all 2^k possible display trees (choose one incoming edge per reticulation)
    k := #reticulationPairs;
    discardedReticulation := apply(2^k,j -> apply(k,l -> reticulationPairs#l#(floor((j%(2^(l+1)))/(2^l)))));
    out := 0;
    edgeVariables := apply(#EPListSorted, j -> findVariable(Rvars,concatenate("e_",toString EPListSorted#j)));
    remainingEdges := edgeVariables;
    for pair in discardedReticulation do (
	for p in pair do remainingEdges = delete(p,remainingEdges);
	prod := 1;
	for ed in remainingEdges do (
	    endPoints := value substring(2,toString ed);
	    -- Set edge ed = 0 to disconnect the two subtrees for evaluating Σ
	    zeroEdges := apply(#pair,j -> pair#j => 0)|{ed => 0};
	    sigmaV := sub(sigma_(endPoints_0-1,0),zeroEdges);
	    sigmaW := sub(sigma_(endPoints_1-1,0),zeroEdges);
	    -- If both endpoints correspond to the trivial group element multiply by a_{v,w}
	    if (sigmaV == 0 or sigmaW == 0) then (
		prod = prod*findVariable(Rvars,concatenate("a_",toString endPoints));
		)else(
		-- Otherwise evaluate the group-sum factor via Σ
		oneEdges := apply(#remainingEdges,j -> remainingEdges#j => 1);
		factorV := sub(sigmaV,oneEdges);
		factorW := sub(sigmaW,oneEdges);
		-- Compute group components (F1,F2) applied to factorV
		element1 := F1 factorV;
		element2 := F2 factorV;
		-- If group element is (0,0) → use a_{v,w}, else b_{v,w}
		if (element1 == 0_W and element2 == 0_W) then (
		    prod = prod*findVariable(Rvars,concatenate("a_",toString endPoints))
		    )else(
		    prod = prod*findVariable(Rvars,concatenate("b_",toString endPoints))
		    );
		)
	    );
	out = out + prod;
	);
    out
    )

-------------------------------------------------------------
-- Helpers---------------------------------------------------
-------------------------------------------------------------

-- This function returns two additive group maps (F1,F2): G^n -> W corresponding to a nucleotide sequence
-- This function is a subroutine for computing q -- it implements the bijection from nucleotide letters A,C,T,G to elements of the Klein 4 group.
-- Here, 'nucleotideSeq' is an equivalence class in L
iMap = method()
iMap (Sequence,ZZ,Ring) := (nucleotideSeq,n,R) -> (
    W := ZZ/2;
    h1 := hashTable{"nucleotideA" => 0_W, "nucleotideC" => 0_W, "nucleotideG" => 1_W, "nucleotideT" => 1_W};
    h2 := hashTable{"nucleotideA" => 0_W, "nucleotideC" => 1_W, "nucleotideG" => 0_W, "nucleotideT" => 1_W};
    F1 := map(W,R,apply(3*n,j->0)|apply(toList nucleotideSeq,j -> h1#("nucleotide"|toString j)));
    F2 := map(W,R,apply(3*n,j->0)|apply(toList nucleotideSeq,j -> h2#("nucleotide"|toString j)));
    return (F1,F2);
    )


-- This function finds a variable in a list of variables given its string name -
-- this is used when working with polynomials which were defined locally (in
-- another function), for which we need to extract the variables.
findVariable = method()
findVariable(List,String) := (varList,varString) -> (
    first select(varList,x -> toString x == varString)
    )



-------------------------------------------------------------
-- Add reticulations to a network ---------------------------
-------------------------------------------------------------

-- Function for constructing networks by adding reticuations

-- This can be run in two modes, either (1) by adding one reticulation at a
-- time, or (2) by adding multiple reticulations at once.

addNetworkEdge = method()
addNetworkEdge (Network,List,ZZ) := (N,edgesToDivide,vertexInNewReticulation) -> (
    edges := getEdges N; reticulationEdges := getReticulationEdges N;
    leaves := getLeaves N; level := getLevel N;
    numVertices := max flatten edges;
    scan(edgesToDivide,e -> assert(#select(reticulationEdges,r -> r_0 == e or r_1 == e) == 0));
    (edgeToDivide1,edgeToDivide2) := toSequence edgesToDivide;
    edgesToAdd := {{edgeToDivide1_0,numVertices+1},{edgeToDivide1_1,numVertices+1},
	{edgeToDivide2_0,numVertices+2},{edgeToDivide2_1,numVertices+2},
	{numVertices+1,numVertices+2}};
    if #(select(edgeToDivide1,v -> v == vertexInNewReticulation)) != 0 then(
	newReticulationEdges := {{{numVertices+1,numVertices+2},{vertexInNewReticulation,numVertices+1}}};
	) else (
	newReticulationEdges = {{{numVertices+1,numVertices+2},{vertexInNewReticulation,numVertices+2}}};
	);
    getNetwork(edges|edgesToAdd,leaves,reticulationEdges|newReticulationEdges)
    )
-* Here's an example of how to use addEdge:
edges = {{1,8},{2,7},{3,6},{4,5},{5,6},{6,7},{7,8},{5,8}};
reticulations = {{{6,7},{7,8}}};
leaves = {1,2,3,4};
exampleNetwork = getNetwork(edges,leaves,reticulations)
exampleNetwork2 = addNetworkEdge(exampleNetwork,{{1,8},{7,2}},7)
peek oo
*-

-- alternative run mode 
addNetworkEdge (Network,List,List) := (N,edgesToDivideList,vertexInNewReticulationList) -> (
    outNetwork := N;
    scan(#edgesToDivideList,i -> outNetwork = addNetworkEdge(outNetwork,edgesToDivideList_i,vertexInNewReticulationList_i));
    outNetwork
    )
-* Here's an example of how to use addEdge:
edges = {{1,8},{2,7},{3,6},{4,5},{5,6},{6,7},{7,8},{5,8}};
reticulations = {{{6,7},{7,8}}};
leaves = {1,2,3,4};
exampleNetwork = getNetwork(edges,leaves,reticulations)
exampleNetwork2 = addNetworkEdge(exampleNetwork,{{{1,8},{7,2}},{{3,6},{4,5}}},{7,3})
peek oo
*-



-------------------------------------------------------------
-- Compute variety dimension numerically---------------------
-------------------------------------------------------------

-- This function computes the dimension of a parameterization numerically
computeDimensionNumerically = method()
computeDimensionNumerically (List) := (parameterization) -> (
    -- Compute the dimension of the parameterization numerically. Input takes
    -- the form of a parameterization without q's, i.e., of the form of the
    -- output of fourLeafParameterization with includeQs=false. Note: this
    -- function requires L to be defined, but should work for any number of
    -- leaves (not just 4) provided that L is defined for that. Last updated
    -- 2024-10-22 by mh
    edgeVariables = flatten entries vars (ring parameterization_0); -- recover the edge parameters used in the parameterization
    randomValues = apply(edgeVariables, i-> i=> random QQ);
    J1 = jacobian matrix{parameterization}; -- compute the symbolic jacobian
    J0 = sub(J1, randomValues); -- substitute in the random variables
    out = rank J0;
    return out;
    )

end
